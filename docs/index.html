<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="SuperF: Neural Implicit Fields for Multi-Image Super-Resolution. Test-time optimization for satellite and handheld bursts.">
    <title>SuperF: Neural Implicit Fields for Multi-Image Super-Resolution</title>

    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">

    <style>
        /* --- CORE STYLES --- */
        :root {
            --primary: #1a1a1a;
            --secondary: #4a5d72;
            --accent: #274060;
            --highlight: #3b82f6;
            --danger: #ef4444; /* For Uncertainty */
            --bg-light: #f8f9fa;
            --text-main: #333;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: 'Inter', sans-serif;
            line-height: 1.6;
            color: var(--text-main);
            background-color: #fff;
            -webkit-font-smoothing: antialiased;
        }

        .container {
            max-width: 1180px;
            margin: 0 auto;
            padding: 0 20px 80px;
        }

        section {
            margin: 100px 0;
            scroll-margin-top: 80px;
        }

        h1 {
            font-size: clamp(40px, 6vw, 64px);
            font-weight: 800;
            color: var(--primary);
            margin-bottom: 24px;
            letter-spacing: -0.03em;
            line-height: 1.1;
        }

        h2 {
            font-size: 36px;
            font-weight: 700;
            color: var(--primary);
            margin-bottom: 40px;
            letter-spacing: -0.02em;
            text-align: center;
        }

        h3 {
            font-size: 24px;
            font-weight: 600;
            color: var(--primary);
            margin-bottom: 16px;
        }

        p {
            font-size: 18px;
            color: #4b5563;
            margin-bottom: 24px;
            line-height: 1.75;
            max-width: 75ch;
            margin-left: auto;
            margin-right: auto;
        }

        /* --- HERO SECTION --- */
        .hero {
            position: relative;
            border-radius: 24px;
            background: radial-gradient(circle at 0% 0%, rgba(59, 130, 246, 0.1), transparent 40%),
                        radial-gradient(circle at 100% 100%, rgba(246, 114, 128, 0.1), transparent 40%),
                        linear-gradient(180deg, #f8fbff 0%, #ffffff 100%);
            padding: 50px 40px;
            margin-top: 40px;
            border: 1px solid rgba(0,0,0,0.03);
        }

        .hero-inner {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            align-items: center;
            gap: 60px;
        }

        .tagline {
            font-size: 24px;
            font-weight: 500;
            color: var(--accent);
            margin-bottom: 24px;
        }

        .links {
            display: flex;
            gap: 16px;
            flex-wrap: wrap;
            margin-top: 32px;
        }

        .btn {
            display: inline-flex;
            align-items: center;
            padding: 12px 28px;
            background-color: var(--primary);
            color: white;
            text-decoration: none;
            border-radius: 8px;
            font-weight: 500;
            transition: transform 0.2s, background-color 0.2s;
        }
        
        .btn:hover { background-color: #000; transform: translateY(-2px); }
        
        .btn.secondary {
            background-color: white;
            color: var(--primary);
            border: 1px solid #e5e7eb;
            box-shadow: 0 1px 2px rgba(0,0,0,0.05);
        }
        
        .btn.secondary:hover { background-color: #f9fafb; border-color: #d1d5db; }

        .hero-media {
            border-radius: 16px;
            overflow: visible;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        /* --- ANIMATION 1: JITTERING FRAMES --- */
        .alignment-container {
            position: relative;
            width: 100%;
            max-width: 500px;
            height: 350px;
            margin: 0 auto;
            display: flex;
            justify-content: center;
            align-items: center;
            background: #f8f9fa;
            border-radius: 16px;
            box-shadow: 0 8px 24px rgba(0,0,0,0.12);
            overflow: hidden;
        }

        /* Hero-specific styling */
        .hero .alignment-container {
            height: 400px;
            box-shadow: 0 12px 32px rgba(0,0,0,0.15);
        }

        /* Side-by-side examples container */
        .examples-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
            gap: 40px;
            margin: 40px 0;
            align-items: start;
        }

        .example-item {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .example-item .alignment-container {
            max-width: 100%;
            width: 100%;
        }

        .example-label {
            font-size: 16px;
            font-weight: 600;
            color: var(--primary);
            margin-bottom: 20px;
            text-align: center;
        }

        .jitter-frame {
            position: absolute;
            width: 100%;
            height: 100%;
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
            border-radius: 8px;
            opacity: 0.4;
            mix-blend-mode: normal;
            image-rendering: pixelated;
            background-color: #e5e7eb; /* Fallback if image doesn't load */
        }

        /* Individual jittering frames with different offsets */
        .jitter-frame-1 {
            animation: jitter1 6s infinite linear, switchImage1 6s infinite linear;
            z-index: 1;
        }

        .jitter-frame-2 {
            animation: jitter2 6s infinite linear, switchImage2 6s infinite linear;
            z-index: 2;
            animation-delay: 0.15s;
        }

        .jitter-frame-3 {
            animation: jitter3 6s infinite linear, switchImage3 6s infinite linear;
            z-index: 3;
            animation-delay: 0.3s;
        }

        /* Island example frames - each uses a different LR image */
        .island-frame-1 {
            animation: jitter1 6s infinite linear, switchIslandImage1 6s infinite linear;
            z-index: 1;
        }

        .island-frame-2 {
            animation: jitter2 6s infinite linear, switchIslandImage2 6s infinite linear;
            z-index: 2;
            animation-delay: 0.15s;
        }

        .island-frame-3 {
            animation: jitter3 6s infinite linear, switchIslandImage3 6s infinite linear;
            z-index: 3;
            animation-delay: 0.3s;
        }

        @keyframes jitter1 {
            0% { 
                transform: translate(15px, 8px) rotate(0.4deg); 
            }
            30% { 
                transform: translate(0px, 0px) rotate(0deg); 
            }
            50% { 
                transform: translate(0px, 0px) rotate(0deg); 
            }
            80% { 
                transform: translate(-15px, 8px) rotate(-0.4deg); 
            }
            100% { 
                transform: translate(15px, 8px) rotate(0.4deg); 
            }
        }

        @keyframes jitter2 {
            0% { 
                transform: translate(-8px, 15px) rotate(-0.3deg); 
            }
            30% { 
                transform: translate(0px, 0px) rotate(0deg); 
            }
            50% { 
                transform: translate(0px, 0px) rotate(0deg); 
            }
            80% { 
                transform: translate(8px, -15px) rotate(0.3deg); 
            }
            100% { 
                transform: translate(-8px, 15px) rotate(-0.3deg); 
            }
        }

        @keyframes jitter3 {
            0% { 
                transform: translate(-10px, -12px) rotate(0.5deg); 
            }
            30% { 
                transform: translate(0px, 0px) rotate(0deg); 
            }
            50% { 
                transform: translate(0px, 0px) rotate(0deg); 
            }
            80% { 
                transform: translate(10px, 12px) rotate(-0.5deg); 
            }
            100% { 
                transform: translate(-10px, -12px) rotate(0.5deg); 
            }
        }

        /* Switch between LR and HR images */
        @keyframes switchImage1 {
            0%, 25% { 
                background-image: url('figs/kjevik_lr.png'); 
                filter: blur(1.5px); 
            }
            30% { 
                background-image: url('figs/kjevik_hr.png'); 
                filter: blur(0px); 
            }
            50% { 
                background-image: url('figs/kjevik_hr.png'); 
                filter: blur(0px); 
            }
            55%, 100% { 
                background-image: url('figs/kjevik_lr.png'); 
                filter: blur(1.5px); 
            }
        }

        @keyframes switchImage2 {
            0%, 25% { 
                background-image: url('figs/kjevik_lr.png'); 
                filter: blur(1.5px); 
            }
            30% { 
                background-image: url('figs/kjevik_hr.png'); 
                filter: blur(0px); 
            }
            50% { 
                background-image: url('figs/kjevik_hr.png'); 
                filter: blur(0px); 
            }
            55%, 100% { 
                background-image: url('figs/kjevik_lr.png'); 
                filter: blur(1.5px); 
            }
        }

        @keyframes switchImage3 {
            0%, 25% { 
                background-image: url('figs/kjevik_lr.png'); 
                filter: blur(1.5px); 
            }
            30% { 
                background-image: url('figs/kjevik_hr.png'); 
                filter: blur(0px); 
            }
            50% { 
                background-image: url('figs/kjevik_hr.png'); 
                filter: blur(0px); 
            }
            55%, 100% { 
                background-image: url('figs/kjevik_lr.png'); 
                filter: blur(1.5px); 
            }
        }

        /* Island example image switching */
        @keyframes switchIslandImage1 {
            0%, 25% { 
                background-image: url('figs/island/LR_1.png'); 
                filter: blur(1.5px); 
            }
            30% { 
                background-image: url('figs/island/HR.png'); 
                filter: blur(0px); 
            }
            50% { 
                background-image: url('figs/island/HR.png'); 
                filter: blur(0px); 
            }
            55%, 100% { 
                background-image: url('figs/island/LR_1.png'); 
                filter: blur(1.5px); 
            }
        }

        @keyframes switchIslandImage2 {
            0%, 25% { 
                background-image: url('figs/island/LR_2.png'); 
                filter: blur(1.5px); 
            }
            30% { 
                background-image: url('figs/island/HR.png'); 
                filter: blur(0px); 
            }
            50% { 
                background-image: url('figs/island/HR.png'); 
                filter: blur(0px); 
            }
            55%, 100% { 
                background-image: url('figs/island/LR_2.png'); 
                filter: blur(1.5px); 
            }
        }

        @keyframes switchIslandImage3 {
            0%, 25% { 
                background-image: url('figs/island/LR_3.png'); 
                filter: blur(1.5px); 
            }
            30% { 
                background-image: url('figs/island/HR.png'); 
                filter: blur(0px); 
            }
            50% { 
                background-image: url('figs/island/HR.png'); 
                filter: blur(0px); 
            }
            55%, 100% { 
                background-image: url('figs/island/LR_3.png'); 
                filter: blur(1.5px); 
            }
        }

        /* --- ANIMATION 2: 3D BURST STACK (Method Section) --- */
        .stack-container {
            perspective: 1200px;
            height: 300px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            margin: 30px 0;
            overflow: visible;
            position: relative;
        }

        .stack-scene {
            position: relative;
            width: 250px; 
            height: 250px;
            transform-style: preserve-3d;
            transform: rotateX(60deg) rotateZ(-30deg);
            transition: transform 0.6s cubic-bezier(0.2, 0.8, 0.2, 1);
        }

        .stack-container:hover .stack-scene {
            transform: rotateX(50deg) rotateZ(-20deg) scale(1.15);
        }

        .layer {
            position: absolute;
            width: 100%; 
            height: 100%;
            background-size: cover;
            background-position: center;
            border-radius: 8px;
            box-shadow: -5px 5px 10px rgba(0,0,0,0.1);
            transition: all 0.5s ease;
            cursor: pointer;
        }

        .layer.lr {
            background-image: url('figs/kjevik_lr.png'); 
            background-color: #ddd; 
            border: 2px solid rgba(255,255,255,0.8);
            image-rendering: pixelated;
        }

        .layer.hr {
            background-image: url('figs/kjevik_hr.png'); 
            background-color: var(--accent); 
            border: 3px solid var(--highlight);
            box-shadow: 0 0 25px rgba(59, 130, 246, 0.4);
            bottom: 0;
            z-index: 50;
        }

        .layer:nth-child(1) { 
            transform: translateZ(0px); 
        }
        .layer:nth-child(2) { 
            animation: alignLayer1 2.8s ease-in-out infinite; 
        }
        .layer:nth-child(3) { 
            animation: alignLayer2 2.8s ease-in-out infinite; 
        }
        .layer:nth-child(4) { 
            animation: alignLayer3 2.8s ease-in-out infinite; 
        }


        @keyframes alignLayer1 {
            0%, 30% { 
                transform: translateZ(60px) translateX(-40px) translateY(-30px) rotate(-3deg); 
                opacity: 0.4; 
            }
            50% { 
                transform: translateZ(60px) translateX(0px) translateY(0px) rotate(0deg); 
                opacity: 0.75; 
            }
            60% { 
                transform: translateZ(60px) translateX(0px) translateY(0px) rotate(0deg); 
                opacity: 0.75; 
            }
            100% { 
                transform: translateZ(60px) translateX(-40px) translateY(-30px) rotate(-3deg); 
                opacity: 0.4; 
            }
        }

        @keyframes alignLayer2 {
            0%, 30% { 
                transform: translateZ(120px) translateX(35px) translateY(30px) rotate(3deg); 
                opacity: 0.35; 
            }
            50% { 
                transform: translateZ(120px) translateX(0px) translateY(0px) rotate(0deg); 
                opacity: 0.6; 
            }
            60% { 
                transform: translateZ(120px) translateX(0px) translateY(0px) rotate(0deg); 
                opacity: 0.6; 
            }
            100% { 
                transform: translateZ(120px) translateX(35px) translateY(30px) rotate(3deg); 
                opacity: 0.35; 
            }
        }

        @keyframes alignLayer3 {
            0%, 30% { 
                transform: translateZ(180px) translateX(-30px) translateY(35px) rotate(-2.5deg); 
                opacity: 0.3; 
            }
            50% { 
                transform: translateZ(180px) translateX(0px) translateY(0px) rotate(0deg); 
                opacity: 0.45; 
            }
            60% { 
                transform: translateZ(180px) translateX(0px) translateY(0px) rotate(0deg); 
                opacity: 0.45; 
            }
            100% { 
                transform: translateZ(180px) translateX(-30px) translateY(35px) rotate(-2.5deg); 
                opacity: 0.3; 
            }
        }

        /* Layer labels */
        .layer-label {
            position: absolute;
            font-size: 11px;
            font-weight: 600;
            color: white;
            background: rgba(0,0,0,0.75);
            padding: 5px 10px;
            border-radius: 6px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s ease;
            white-space: nowrap;
            backdrop-filter: blur(4px);
            z-index: 100;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
        }

        .stack-container:hover .layer-label {
            opacity: 1;
        }

        .layer-label.hr-label {
            bottom: -30px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(59, 130, 246, 0.9);
        }

        .layer-label.lr-label {
            top: -30px;
            left: 50%;
            transform: translateX(-50%);
        }

        /* --- TIMELAPSE ANIMATION --- */
        .timelapse-container {
            max-width: 500px;
            margin: 60px auto;
            border-radius: 16px;
            overflow: hidden;
            box-shadow: 0 20px 60px rgba(0,0,0,0.15);
            border: 4px solid white;
            background: #000;
            position: relative;
            display: inline-block;
            line-height: 0;
        }

        .timelapse-frame {
            display: block;
            width: auto;
            height: auto;
            max-width: 100%;
            opacity: 0;
            transition: opacity 0.3s ease-in-out;
        }

        .timelapse-frame.loaded {
            opacity: 1;
        }

        .timelapse-controls {
            max-width: 1000px;
            margin: 20px auto 0;
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .timelapse-slider {
            flex: 1;
            height: 6px;
            border-radius: 3px;
            background: #e5e7eb;
            outline: none;
            -webkit-appearance: none;
            appearance: none;
        }

        .timelapse-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: var(--highlight);
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }

        .timelapse-slider::-moz-range-thumb {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: var(--highlight);
            cursor: pointer;
            border: none;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }

        .timelapse-frame-info {
            font-size: 14px;
            color: #6b7280;
            min-width: 80px;
            text-align: right;
        }

        .timelapse-selector {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-top: 30px;
            flex-wrap: wrap;
        }

        .timelapse-option {
            cursor: pointer;
            border: 3px solid transparent;
            border-radius: 12px;
            padding: 8px;
            background: white;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            transition: all 0.3s ease;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
        }

        .timelapse-option:hover {
            box-shadow: 0 6px 16px rgba(0,0,0,0.15);
            transform: translateY(-2px);
        }

        .timelapse-option.active {
            border-color: var(--highlight);
            box-shadow: 0 6px 20px rgba(59, 130, 246, 0.3);
        }

        .timelapse-preview {
            width: 120px;
            height: 120px;
            object-fit: contain;
            border-radius: 8px;
            background: #000;
        }

        .timelapse-option-label {
            font-size: 14px;
            font-weight: 600;
            color: var(--primary);
        }

        /* --- SHARED LENS STYLES --- */
        .lens-wrapper {
            position: relative;
            max-width: 800px;
            margin: 40px auto;
            border-radius: 12px;
            overflow: hidden;
            cursor: crosshair;
            box-shadow: 0 20px 40px -5px rgba(0,0,0,0.2);
            border: 4px solid white;
        }

        .img-base {
            display: block;
            width: 100%;
            height: auto;
            filter: blur(1px) grayscale(0.2); 
            transition: filter 0.3s;
        }

        .lens-wrapper:hover .img-base {
            filter: blur(2px) grayscale(0.4);
        }

        .lens {
            position: absolute;
            width: 280px; height: 280px;
            border-radius: 50%;
            border: 3px solid #fff;
            
            box-shadow: 0 10px 25px rgba(0,0,0,0.4);
            background-repeat: no-repeat;
            background-size: cover; /* Will be overwritten by JS */
            
            display: none;
            pointer-events: none;
            z-index: 100;
        }

        .lens-hint {
            position: absolute;
            top: 20px; left: 20px;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 13px;
            pointer-events: none;
            backdrop-filter: blur(4px);
        }

        /* Specific styles for Uncertainty Lens */
        .uncertainty-lens {
            border-color: var(--danger); /* Red border to signify "alert" */
            box-shadow: 0 0 20px rgba(239, 68, 68, 0.4);
        }
        
        .uncertainty-img {
            /* Simulates a heatmap if you don't have the exact image yet. 
               Remove this filter if your 'figs/uncertainty_map.png' is already a colored heatmap. */
            filter: invert(1) hue-rotate(180deg) contrast(1.5); 
        }

        /* --- METRICS & MATH --- */
        .metrics-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
            gap: 24px;
            margin-bottom: 60px;
        }

        .metric-card {
            background: #fff;
            padding: 32px 24px;
            border-radius: 16px;
            border: 1px solid #e5e7eb;
            text-align: center;
            box-shadow: 0 4px 6px -1px rgba(0,0,0,0.05);
        }

        .metric-val { font-size: 42px; font-weight: 800; color: var(--primary); line-height: 1; margin-bottom: 8px; }
        .metric-label { font-size: 14px; font-weight: 600; text-transform: uppercase; color: #9ca3af; letter-spacing: 0.05em; }
        .metric-detail { font-size: 14px; color: var(--highlight); margin-top: 12px; font-weight: 500; }

        .math-block {
            overflow-x: auto;
            padding: 30px;
            background: var(--bg-light);
            border-radius: 12px;
            margin: 40px auto;
            text-align: center;
            font-size: 1.2em;
            max-width: 900px;
        }

        .abstract {
            background: var(--bg-light);
            padding: 48px;
            border-radius: 24px;
            margin: 0 auto;
            max-width: 960px;
            border-left: 6px solid var(--primary);
        }

        /* --- WHY SUPERF SECTION --- */
        .why-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 32px;
            margin: 60px 0;
        }

        .why-card {
            background: white;
            padding: 40px 32px;
            border-radius: 20px;
            border: 1px solid #e5e7eb;
            box-shadow: 0 4px 6px -1px rgba(0,0,0,0.05);
            transition: transform 0.3s, box-shadow 0.3s;
        }

        .why-card:hover {
            transform: translateY(-4px);
            box-shadow: 0 12px 24px -4px rgba(0,0,0,0.1);
        }

        .why-card h3 {
            font-size: 22px;
            margin-bottom: 16px;
            color: var(--primary);
        }

        .why-card p {
            font-size: 16px;
            color: #6b7280;
            margin-bottom: 0;
            max-width: 100%;
        }

        .why-card strong {
            color: var(--highlight);
            font-weight: 600;
        }

        /* --- QUICK START SECTION --- */
        .code-block {
            background: #1f2937;
            color: #f3f4f6;
            padding: 24px;
            border-radius: 12px;
            overflow-x: auto;
            margin: 24px 0;
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            font-size: 14px;
            line-height: 1.6;
        }

        .code-block code {
            color: inherit;
        }

        .param-table {
            width: 100%;
            border-collapse: collapse;
            margin: 32px 0;
            background: white;
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }

        .param-table th {
            background: var(--bg-light);
            padding: 16px;
            text-align: left;
            font-weight: 600;
            color: var(--primary);
            border-bottom: 2px solid #e5e7eb;
        }

        .param-table td {
            padding: 16px;
            border-bottom: 1px solid #f3f4f6;
            color: #4b5563;
        }

        .param-table tr:last-child td {
            border-bottom: none;
        }

        /* --- PROBLEM SECTION ENHANCEMENT --- */
        .problem-content {
            max-width: 900px;
            margin: 0 auto;
        }

        .problem-points {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 24px;
            margin: 40px 0;
        }

        .problem-point {
            padding: 24px;
            background: #f9fafb;
            border-radius: 12px;
            border-left: 4px solid var(--highlight);
        }

        .problem-point strong {
            display: block;
            color: var(--primary);
            margin-bottom: 8px;
            font-size: 18px;
        }

        /* --- METHODOLOGY ENHANCEMENT --- */
        .method-steps {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 32px;
            margin: 40px 0;
        }

        .method-step {
            padding: 32px;
            background: white;
            border-radius: 16px;
            border: 1px solid #e5e7eb;
        }

        .method-step h4 {
            font-size: 20px;
            color: var(--primary);
            margin-bottom: 12px;
            font-weight: 600;
        }

        .method-step p {
            font-size: 15px;
            color: #6b7280;
            margin-bottom: 0;
            max-width: 100%;
        }

        /* --- FOOTER --- */
        footer {
            margin-top: 120px;
            padding: 60px 0;
            border-top: 1px solid #eee;
            text-align: center;
            color: #9ca3af;
        }

        footer p {
            margin-bottom: 8px;
            max-width: 100%;
        }

        /* --- RESPONSIVE --- */
        @media (max-width: 768px) {
            h1 { font-size: 36px; }
            h2 { font-size: 28px; }
            .hero { padding: 40px 24px; }
            .hero .alignment-container {
                height: 280px;
                max-width: 100%;
            }
            .abstract { padding: 24px; }
            .stack-container { transform: scale(0.8); }
            .alignment-container {
                width: 100%;
                max-width: 300px;
                height: 225px;
            }
            .why-grid, .method-steps, .problem-points {
                grid-template-columns: 1fr;
            }
            .examples-container {
                grid-template-columns: 1fr;
                gap: 40px;
            }
            .timelapse-container {
                margin: 40px auto;
                border-radius: 12px;
            }
            .param-table {
                font-size: 12px;
            }
            .param-table th,
            .param-table td {
                padding: 12px 8px;
            }
        }

        /* --- ZOOMED INSET VISUALIZATION --- */
        .zoomed-comparison {
            max-width: 900px;
            margin: 40px auto;
            background: #fff;
            border-radius: 16px;
            box-shadow: 0 4px 6px -1px rgba(0,0,0,0.05);
            border: 1px solid #e5e7eb;
            overflow: hidden;
        }
        .main-context {
            position: relative;
            width: 100%;
            max-width: 520px;
            aspect-ratio: 1 / 1;
            border-bottom: 1px solid #e5e7eb;
            cursor: grab;
            user-select: none;
            overflow: hidden;
            margin: 0 auto;
        }
        .main-context.dragging {
            cursor: grabbing;
        }
        .main-context img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            display: block;
        }
        /* The Red Box indicating the crop area */
        .zoom-indicator-box {
            position: absolute;
            border: 2px solid var(--danger);
            box-shadow: 0 0 0 1000px rgba(0,0,0,0.3); /* Dim the outside area */
            z-index: 10;
            pointer-events: none;
            transition: transform 0.1s ease-out;
        }
        .zoom-indicator-label {
            position: absolute;
            top: -25px;
            left: 0;
            background: var(--danger);
            color: white;
            font-size: 10px;
            font-weight: bold;
            padding: 2px 6px;
            border-radius: 4px;
        }
        .crops-row {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 2px; /* Small gap for border separator */
            background: #e5e7eb;
        }
        .crop-container {
            background: #fff;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        .crop-view {
            width: 200px;
            height: 200px;
            border-radius: 8px;
            border: 1px solid #eee;
            margin-bottom: 12px;
            box-shadow: inset 0 0 20px rgba(0,0,0,0.05);
            overflow: hidden;
        }
        .crop-view {
            position: relative;
        }
        .crop-view canvas {
            width: 100%;
            height: 100%;
            display: block;
            image-rendering: pixelated;
        }
        .crop-label {
            font-weight: 600;
            color: var(--primary);
            font-size: 14px;
        }
        .crop-sub {
            font-size: 12px;
            color: #9ca3af;
        }

        /* --- INPUT VS OUTPUT SLIDER COMPARISON --- */
        .comparison-gallery {
            margin: 60px auto 0;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 32px;
            max-width: 1000px;
        }
        .comparison-card {
            --percent: 50;
            background: #fff;
            border-radius: 20px;
            border: 1px solid #e5e7eb;
            padding: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.08);
            display: flex;
            flex-direction: column;
            gap: 18px;
        }
        .comparison-stage {
            position: relative;
            width: 100%;
            border-radius: 16px;
            overflow: hidden;
            background: #000;
            cursor: ew-resize;
            user-select: none;
            touch-action: none;
            line-height: 0;
        }
        .comparison-image {
            width: 100%;
            height: auto;
            object-fit: cover;
            display: block;
            pointer-events: none;
            -webkit-user-drag: none;
            user-select: none;
        }
        .comparison-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            clip-path: inset(0 calc(100% - (var(--percent) * 1%)) 0 0);
        }
        .comparison-overlay img {
            width: 100%;
            height: auto;
            display: block;
            object-fit: cover;
            image-rendering: pixelated;
        }
        .comparison-handle {
            position: absolute;
            top: 50%;
            left: calc(var(--percent) * 1%);
            transform: translate(-50%, -50%);
            width: 38px;
            height: 38px;
            border-radius: 50%;
            border: 3px solid rgba(255,255,255,0.9);
            background: rgba(0,0,0,0.45);
            display: grid;
            place-items: center;
            color: white;
            font-size: 16px;
            cursor: grab;
            pointer-events: none;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        }
        .comparison-divider {
            position: absolute;
            top: 0;
            bottom: 0;
            width: 2px;
            background: rgba(255,255,255,0.9);
            left: calc(var(--percent) * 1%);
            transform: translateX(-1px);
            pointer-events: none;
        }
        .comparison-handle::before,
        .comparison-handle::after {
            content: '';
            width: 0;
            height: 0;
            border-top: 6px solid transparent;
            border-bottom: 6px solid transparent;
        }
        .comparison-handle::before {
            border-right: 8px solid white;
            margin-right: 4px;
        }
        .comparison-handle::after {
            border-left: 8px solid white;
            margin-left: 4px;
        }
        .comparison-label {
            position: absolute;
            top: 16px;
            padding: 4px 10px;
            font-size: 12px;
            font-weight: 600;
            border-radius: 999px;
            color: white;
            background: rgba(0,0,0,0.55);
            pointer-events: none;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }
        .comparison-label-left { left: 16px; }
        .comparison-label-right { right: 16px; }
        .comparison-caption {
            font-size: 14px;
            text-align: center;
            color: #6b7280;
            margin-bottom: 0;
        }
    </style>
</head>
<body>

    <div class="container">
        
        <header class="hero">
            <div class="hero-inner">
                <div class="hero-text">
                    <h1>SuperF</h1>
                    <p class="tagline">Neural Implicit Fields for Multi-Image Super-Resolution</p>
                    <p style="font-size: 16px; color: var(--secondary);">
                        Reconstructing real detail from handheld bursts and satellite time series &mdash; <span style="color: var(--primary); font-weight: 600;">no HR training data required.</span>
                    </p>
                    <div class="links">
                        <a href="https://github.com/yourusername/superf" class="btn">Code</a>
                        <a href="SuperF.pdf" class="btn secondary">Paper</a>
                        <a href="#demo" class="btn secondary">Demo</a>
                        <a href="#results" class="btn secondary">Results</a>
                    </div>
                </div>
                <div class="hero-media">
                    <div class="stack-container">
                        <div class="stack-scene">
                            <div class="layer hr" style="--z-pos: 0px;">
                                <div class="layer-label hr-label">HR Reconstruction</div>
                            </div>
                            <div class="layer lr" style="--z-pos: 60px;">
                                <div class="layer-label lr-label">LR Frame 1</div>
                            </div>
                            <div class="layer lr" style="--z-pos: 120px;">
                                <div class="layer-label lr-label">LR Frame 2</div>
                            </div>
                            <div class="layer lr" style="--z-pos: 180px;">
                                <div class="layer-label lr-label">LR Frame 3</div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </header>

        <section id="abstract">
            <h2>Abstract</h2>
            <div class="abstract">
                <p>
                    High-resolution imagery is often hindered by limitations in sensor technology, atmospheric conditions, and costs. Such challenges occur in satellite remote sensing, but also with handheld cameras, such as our smartphones. Hence, super-resolution aims to enhance image resolution algorithmically. Since single-image super-resolution requires solving an inverse problem, such methods must exploit strong priors, e.g. learned from high-resolution training data, or be constrained by auxiliary data, e.g. by a high-resolution guide from another modality. While qualitatively pleasing, such approaches often lead to hallucinated structures that do not match reality.
                </p>
                <p>
                    In contrast, multi-image super-resolution (MISR) aims to improve resolution by constraining the reconstruction with multiple views taken with sub-pixel shifts. We propose SuperF, a test-time optimization approach for MISR that leverages coordinate-based neural networks, also called neural fields. Their ability to represent continuous signals with an implicit neural representation (INR) makes them an ideal fit for the MISR task. The key characteristic of our approach is to share an INR for multiple shifted low-resolution frames and to jointly optimize the frame alignment with the INR. Our approach advances related INR baselines by directly parameterizing the sub-pixel alignment as optimizable affine transformation parameters and by optimizing via a super-sampled coordinate grid that corresponds to the output resolution. Our experiments yield compelling results on simulated bursts of satellite imagery and ground-level images from handheld cameras, with upsampling factors of up to 8. A key advantage of SuperF is that this approach does not rely on any high-resolution training data.
                </p>
            </div>
        </section>

        <section id="why">
            <h2>Why SuperF</h2>
            <p style="text-align: center; max-width: 800px;">
                SuperF is a neural-field approach to multi-image super-resolution that turns bursts and time series into photorealistic high-resolution imagery—without ever seeing high-resolution training data. We jointly optimize sub-pixel alignments with a shared implicit neural representation, so every frame contributes real signal instead of hallucinated texture.
            </p>
            <p style="text-align: center; max-width: 800px; margin-bottom: 40px;">
                Built for practitioners, SuperF shines on synthetic satellite bursts, handheld smartphone sequences, and real Sentinel-2 orbits. Drop it into your existing pipeline, let it optimize for a couple of minutes, and you get clean, high-frequency detail that previous test-time baselines miss.
            </p>
        </section>

        <section id="problem">
            <h2>Problem</h2>
            <div class="problem-content">
                <p>
                    Imaging systems from satellites to smartphones are constrained by optics, weather, and motion. Multi-image super-resolution captures bursts with natural sub-pixel shifts, embedding high-frequency detail across frames. However, prior approaches either rely on heavy training pipelines that hallucinate texture, or on classical test-time optimization that struggles to recover crisp structure.
                </p>
                <p style="text-align: center; font-weight: 600; color: var(--primary); margin: 32px 0;">
                    <strong>SuperF</strong> bridges that gap: a neural implicit representation that you optimize only at inference time, aligning every frame and rendering a continuous, alias-free reconstruction of the scene.
                </p>
                <p>
                    Real bursts jitter — each LR frame samples the scene with different sub-pixel offsets and aliasing patterns.
                </p>

                <div class="examples-container">
                    <div class="example-item">
                        <div class="alignment-container">
                            <div class="jitter-frame jitter-frame-1"></div>
                            <div class="jitter-frame jitter-frame-2"></div>
                            <div class="jitter-frame jitter-frame-3"></div>
                        </div>
                    </div>
                    
                    <div class="example-item">
                        <div class="alignment-container">
                            <div class="jitter-frame island-frame-1"></div>
                            <div class="jitter-frame island-frame-2"></div>
                            <div class="jitter-frame island-frame-3"></div>
                        </div>
                    </div>
                </div>
                
                <p style="text-align: center; font-size: 14px; color: #6b7280; margin-top: 20px;">
                    Three transparent low-resolution frames jitter with sub-pixel shifts. When they overlap perfectly, they combine to create a clear, sharp image. Each frame uses a different low-resolution capture.
                </p>
            </div>
        </section>

        <section id="method">
            <h2>Methodology</h2>
            <p>
                SuperF formulates MISR as the joint optimization of a shared coordinate-based MLP and frame-specific alignment parameters. The INR takes continuous spatial coordinates and outputs RGB intensities, enabling a continuous representation of the scene while maintaining differentiability with respect to spatial transforms.
            </p>

            <div style="text-align: center; margin: 40px 0 20px 0;">
                <h3 style="text-align: center; margin-bottom: 16px;">Shared Implicit Neural Representation (INR)</h3>
                <p style="max-width: 800px; margin: 0 auto;">
                    Everything revolves around a single coordinate-based MLP \(f_\theta\) that maps high-resolution coordinates to RGB values. This shared INR is the canvas on which all burst frames agree, so once it is optimized, rendering any viewpoint is just evaluation at continuous coordinates.
                </p>
            </div>

            <div class="method-steps">
                <div class="method-step">
                    <h4>Joint alignment optimization</h4>
                    <p>
                        For each burst frame we learn a tiny affine transform (two translations + one rotation) relative to a base frame. These alignment parameters are optimized together with \(\theta\), turning jitter into precise sub-pixel shifts that enrich the INR.
                    </p>
                </div>
                <div class="method-step">
                    <h4>Supersampled supervision</h4>
                    <p>
                        We query the INR on a dense HR grid, average-pool the predictions down to LR, and match them to the observed pixels. This supersampling bridge lets us recover detail beyond the LR pixel lattice without hallucination.
                    </p>
                </div>
                <div class="method-step">
                    <h4>Fourier feature encoding</h4>
                    <p>
                        A Fourier positional encoding feeds the MLP with rich frequency bases, preventing spectral bias so SuperF can learn the high-frequency signals that multi-image super-resolution depends on.
                    </p>
                </div>
            </div>

            <div style="text-align: center; margin: 40px 0 20px 0;">
                <p style="max-width: 700px; margin: 0 auto;">
                    <strong>Multiple low-resolution frames</strong> are fused into a single <strong>high-resolution reconstruction</strong> through the shared INR. The animation shows how misaligned burst frames converge and stack to create the final output.
                </p>
            </div>

            <h3>Optimization Objective</h3>
            <p>
                Let \(y_{LR}^{(t)}\) denote the \(t\)-th low-resolution frame sampled on grid \(\mathcal{W}\), and let \(\hat{A}^{(t)}\) be the affine transform aligning the frame to the base coordinate system. The INR produces high-resolution values \(f_\theta(\hat{A}^{(t)}v)\) for coordinates \(v\) on the dense grid. A fixed box filter \(\varphi\) corresponds to average pooling between HR and LR grids. SuperF minimizes:
            </p>

            <div class="math-block">
                $$ \mathcal{L}(\theta, \{\hat{A}\}) = \frac{1}{T} \sum_{t=1}^{T} \sum_{v \in \mathcal{W}} \ell \left( \varphi * \hat{\rho}^{(t)} \left( f_{\theta}(\hat{A}^{(t)}v) \right), y_{LR}^{(t)}(v) \right) $$
            </div>

            <p>
                where \(\hat{\rho}^{(t)}\) is a lightweight per-frame spectral projection (scale and bias per channel) that accounts for photometric differences across frames. Optimization uses AdamW with cosine learning-rate decay over 2k iterations.
            </p>
        </section>

        <section id="uncertainty">
            <h2>Robustness & Uncertainty</h2>
            <p>
                Real-world data is messy. Clouds, shadows, and seasonal drift violate standard MISR assumptions. 
                SuperF uses a <strong>Gaussian Negative Log-Likelihood (GNLL) loss</strong> to predict pixel-wise uncertainty. 
            </p>

        </section>

        <section id="results">
            <h2>Results</h2>
            <p style="text-align: center; font-weight: 600; color: var(--primary); margin-bottom: 40px;">
                <strong>SuperF consistently beats the best publicly available test-time methods</strong>—delivering sharper detail, lower perceptual error, and rock-solid alignment across every dataset we tried.
            </p>

            <ul style="max-width: 800px; margin: 40px auto; padding-left: 24px; color: #4b5563; line-height: 1.8;">
                <li>Handles upsampling factors up to ×8 on synthetic bursts with clean, alias-free detail.</li>
                <li>Generalizes from simulation to real Sentinel-2 time series, delivering 5× zoom-ins on critical infrastructure and landscapes.</li>
                <li>Runs entirely at test time; just provide a burst, let SuperF optimize for 2k steps, and export the high-resolution render.</li>
            </ul>

            <div class="zoomed-comparison">
                <div class="main-context">
                    <img src="figs/kjevik_hr.png" alt="Main context" id="main-context-img">
                    <div class="zoom-indicator-box">
                        <span class="zoom-indicator-label">ZOOM AREA</span>
                    </div>
                </div>

                <div class="crops-row">
                    <div class="crop-container">
                        <div class="crop-view lr-view">
                            <canvas id="lr-crop-canvas" width="200" height="200" data-src="figs/kjevik_lr.png"></canvas>
                        </div>
                        <div class="crop-label">Low-Res Input</div>
                        <div class="crop-sub">(Nearest Neighbor)</div>
                    </div>

                    <div class="crop-container">
                        <div class="crop-view hr-view">
                            <canvas id="hr-crop-canvas" width="200" height="200"></canvas>
                        </div>
                        <div class="crop-label">SuperF Output</div>
                        <div class="crop-sub">(Ours)</div>
                    </div>
                </div>
            </div>

            <div class="comparison-gallery">
                <div class="comparison-card">
                    <div class="comparison-stage">
                        <img src="figs/kjevik_hr.png" alt="SuperF reconstruction" class="comparison-image base">
                        <div class="comparison-overlay">
                            <img src="figs/kjevik_lr.png" alt="Low-resolution burst input" class="comparison-image overlay">
                        </div>
                        <div class="comparison-divider" aria-hidden="true"></div>
                        <div class="comparison-label comparison-label-left">Input</div>
                        <div class="comparison-label comparison-label-right">Ours</div>
                        <div class="comparison-handle" aria-hidden="true"></div>
                    </div>
                    <p class="comparison-caption">Handheld burst (Kjevik)</p>
                </div>

                <div class="comparison-card">
                    <div class="comparison-stage">
                        <img src="figs/island/HR.png" alt="SuperF reconstruction (island)" class="comparison-image base">
                        <div class="comparison-overlay">
                            <img src="figs/island/LR_1.png" alt="Low-resolution island input" class="comparison-image overlay">
                        </div>
                        <div class="comparison-divider" aria-hidden="true"></div>
                        <div class="comparison-label comparison-label-left">Input</div>
                        <div class="comparison-label comparison-label-right">Ours</div>
                        <div class="comparison-handle" aria-hidden="true"></div>
                    </div>
                    <p class="comparison-caption">Satellite burst (Island)</p>
                </div>
            </div>

        </section>

        <section id="timelapse">
            <h2>Timelapse</h2>
            <p style="text-align: center; max-width: 800px; margin-bottom: 20px;">
                Watch SuperF reconstruct high-resolution detail over time as the optimization progresses. Each frame shows the evolving reconstruction during test-time optimization.
            </p>
            <div style="text-align: center;">
                <div class="timelapse-container">
                    <img id="timelapse-img" class="timelapse-frame" alt="Timelapse animation" style="display: block;">
                </div>
            </div>
            <div class="timelapse-controls">
                <input type="range" id="timelapse-slider" class="timelapse-slider" min="0" max="29" value="0" step="1">
                <span class="timelapse-frame-info" id="timelapse-frame-info">Frame 1 / 30</span>
            </div>
            <div class="timelapse-selector">
                <div class="timelapse-option active" data-timelapse="kjevik">
                    <img src="figs/timelapse/frame_001979.png" class="timelapse-preview" alt="Kjevik preview">
                    <span class="timelapse-option-label">Kjevik</span>
                </div>
                <div class="timelapse-option" data-timelapse="island">
                    <img src="figs/timelapse_island/frame_001999.png" class="timelapse-preview" alt="Island preview">
                    <span class="timelapse-option-label">Island</span>
                </div>
                <div class="timelapse-option" data-timelapse="roundabout">
                    <img src="figs/timelapse_roundabout/frame_001996.png" class="timelapse-preview" alt="Roundabout preview">
                    <span class="timelapse-option-label">Roundabout</span>
                </div>
            </div>
            <p style="text-align: center; font-size: 14px; color: #6b7280; margin-top: 20px;">
                The timelapse shows the progressive refinement of the high-resolution reconstruction throughout the optimization process.
            </p>
        </section>

        <section id="demo">
            <h2>Interactive Demo</h2>
            <p>
                Try SuperF in your browser: upload your burst, watch the joint alignment converge, and inspect the super-resolved render directly. The demo runs a lighter-weight configuration so you can get a feel for the workflow before running the full-resolution scripts locally.
            </p>
            <div style="margin-top: 24px; border-radius: 12px; overflow: hidden; border: 1px solid #e5e7eb; box-shadow: 0 10px 30px rgba(0,0,0,0.05);">
                <gradio-app src="https://sjyhne-superf-demo.hf.space" style="width: 100%; min-height: 600px;"></gradio-app>
            </div>
        </section>


        <section>
            <h2>Citation</h2>
            <pre style="background: #1f2937; color: #f3f4f6; padding: 24px; border-radius: 12px; overflow-x: auto;"><code>@article{superf2026,
  title={SuperF: Neural Implicit Fields for Multi-Image Super-Resolution},
  author={Anonymous},
  journal={Under Review (ICLR)},
  year={2026}
}</code></pre>
        </section>

        <footer>
            <p>&copy; 2026 SuperF Project</p>
            <p style="font-size: 14px; margin-top: 10px;">Website template inspired by Nerfies</p>
        </footer>

    </div>

    <script type="module" src="https://gradio.s3-us-west-2.amazonaws.com/4.12.0/gradio.js"></script>
    <script>
        // --- GENERIC MAGIC LENS LOGIC ---
        // This function enables the lens effect on any container with the right structure
        function initLens(containerId, lensId) {
            const container = document.getElementById(containerId);
            const lens = document.getElementById(lensId);
            
            if(!container || !lens) return;

            function moveLens(e) {
                const rect = container.getBoundingClientRect();
                let x = e.clientX - rect.left;
                let y = e.clientY - rect.top;

                // Clamp bounds
                if (x < 0) x = 0; if (x > rect.width) x = rect.width;
                if (y < 0) y = 0; if (y > rect.height) y = rect.height;

                // Move lens (half of 280px = 140px)
                const halfSize = 140; 
                lens.style.left = (x - halfSize) + 'px';
                lens.style.top = (y - halfSize) + 'px';

                // Position background Absolute to Container (No parallax)
                const bgLeft = -1 * x + halfSize; 
                const bgTop = -1 * y + halfSize;
                
                lens.style.backgroundPosition = `${bgLeft}px ${bgTop}px`;
                lens.style.backgroundSize = `${rect.width}px ${rect.height}px`;
            }

            container.addEventListener('mousemove', moveLens);
            container.addEventListener('mouseenter', () => { 
                lens.style.display = 'block'; 
                const rect = container.getBoundingClientRect();
                lens.style.backgroundSize = `${rect.width}px ${rect.height}px`;
            });
            container.addEventListener('mouseleave', () => { lens.style.display = 'none'; });
            container.addEventListener('touchmove', (e) => { e.preventDefault(); moveLens(e.touches[0]); }, { passive: false });
        }

        // --- TIMELAPSE ANIMATION ---
        function initTimelapse() {
            const timelapseImg = document.getElementById('timelapse-img');
            const timelapseSlider = document.getElementById('timelapse-slider');
            const timelapseFrameInfo = document.getElementById('timelapse-frame-info');
            const timelapseOptions = document.querySelectorAll('.timelapse-option');
            if (!timelapseImg || !timelapseSlider) return;

            // Define both timelapses
            const timelapses = {
                kjevik: {
                    folder: 'timelapse',
                    frames: [
                        '000001', '000024', '000047', '000070', '000093', '000116', '000139', '000162',
                        '000185', '000208', '000231', '000254', '000277', '000300', '000323', '000346',
                        '000369', '000392', '000415', '000438', '000461', '000484', '000507', '000530',
                        '000553', '000576', '000599', '000622', '000645', '000668', '000691', '000714',
                        '000737', '000760', '000783', '000806', '000829', '000852', '000875', '000898',
                        '000921', '000944', '000967', '000990', '001013', '001036', '001059', '001082',
                        '001105', '001128', '001151', '001174', '001197', '001220', '001243', '001266',
                        '001289', '001312', '001335', '001358', '001381', '001404', '001427', '001450',
                        '001473', '001496', '001519', '001542', '001565', '001588', '001611', '001634',
                        '001657', '001680', '001703', '001726', '001749', '001772', '001795', '001818',
                        '001841', '001864', '001887', '001910', '001933', '001956', '001979'
                    ]
                },
                island: {
                    folder: 'timelapse_island',
                    frames: [
                        '000001', '000010', '000019', '000028', '000037', '000046', '000055', '000064',
                        '000073', '000082', '000091', '000100', '000109', '000118', '000127', '000136',
                        '000145', '000154', '000163', '000172', '000181', '000190',
                        '000199', '000208', '000217', '000226', '000235', '000244', '000253',
                        '000262', '000271', '000280', '000289', '000298', '000307', '000316', '000325',
                        '000334', '000343', '000352', '000361', '000370', '000379', '000388',
                        '000397', '000406', '000415', '000424', '000433', '000442', '000451', '000460',
                        '000469', '000478', '000487', '000496', '000505', '000514', '000523', '000532',
                        '000541', '000550', '000559', '000568', '000577', '000586', '000595',
                        '000604', '000613', '000622', '000631', '000640', '000649', '000658',
                        '000667', '000676', '000685', '000694', '000703', '000712', '000721', '000730',
                        '000739', '000748', '000757', '000766', '000775', '000784', '000793', '000802',
                        '000811', '000820', '000829', '000838', '000847', '000856', '000865', '000874',
                        '000883', '000892', '000901', '000910', '000919', '000928', '000937', '000946',
                        '000955', '000964', '000973', '000982', '000991', '001000', '001009', '001018',
                        '001027', '001036', '001045', '001054', '001063', '001072', '001081', '001090',
                        '001099', '001108', '001117', '001126', '001135', '001144', '001153',
                        '001162', '001171', '001180', '001189', '001198', '001207', '001216', '001225', '001234',
                        '001243', '001252', '001261', '001270', '001279', '001288', '001297', '001306',
                        '001315', '001324', '001333', '001342', '001351', '001360', '001369', '001378',
                        '001387', '001396', '001405', '001414', '001423', '001432', '001441', '001450',
                        '001459', '001468', '001477', '001486', '001495', '001504', '001513', '001522',
                        '001531', '001540', '001549', '001558', '001567', '001576', '001585', '001594',
                        '001603', '001612', '001621', '001630', '001639', '001648', '001657', '001666',
                        '001675', '001684', '001693', '001702', '001711', '001720', '001729', '001738',
                        '001747', '001756', '001765', '001774', '001783', '001792', '001801', '001810',
                        '001819', '001828', '001837', '001846', '001855', '001864', '001873', '001882',
                        '001891', '001900', '001909', '001918', '001927', '001936', '001945', '001954',
                        '001963', '001972', '001981', '001990', '001999'
                    ]
                },
                roundabout: {
                    folder: 'timelapse_roundabout',
                    frames: [
                        '000001', '000008', '000015', '000022', '000029', '000036', '000043', '000050',
                        '000057', '000064', '000071', '000078', '000085', '000092', '000099', '000106',
                        '000113', '000120', '000127', '000134', '000141', '000148', '000155', '000162',
                        '000169', '000176', '000183', '000190', '000197', '000204', '000211', '000218',
                        '000225', '000232', '000239', '000246', '000253', '000260', '000267', '000274',
                        '000281', '000288', '000295', '000302', '000309', '000316', '000323', '000330',
                        '000337', '000344', '000351', '000358', '000365', '000372', '000379', '000386',
                        '000393', '000400', '000407', '000414', '000421', '000428', '000435', '000442',
                        '000449', '000456', '000463', '000470', '000477', '000484', '000491', '000498',
                        '000505', '000512', '000519', '000526', '000533', '000540', '000547', '000554',
                        '000561', '000568', '000575', '000582', '000589', '000596', '000603', '000610',
                        '000617', '000624', '000631', '000638', '000645', '000652', '000659', '000666',
                        '000673', '000680', '000687', '000694', '000701', '000708', '000715', '000722',
                        '000729', '000736', '000743', '000750', '000757', '000764', '000771', '000778',
                        '000785', '000792', '000799', '000806', '000813', '000820', '000827', '000834',
                        '000841', '000848', '000855', '000862', '000869', '000876', '000883', '000890',
                        '000897', '000904', '000911', '000918', '000925', '000932', '000939', '000946',
                        '000953', '000960', '000967', '000974', '000981', '000988', '000995', '001002',
                        '001009', '001016', '001023', '001030', '001037', '001044', '001051', '001058',
                        '001065', '001072', '001079', '001086', '001093', '001100', '001107', '001114',
                        '001121', '001128', '001135', '001142', '001149', '001156', '001163', '001170',
                        '001177', '001184', '001191', '001198', '001205', '001212', '001219', '001226',
                        '001233', '001240', '001247', '001254', '001261', '001268', '001275', '001282',
                        '001289', '001296', '001303', '001310', '001317', '001324', '001331', '001338',
                        '001345', '001352', '001359', '001366', '001373', '001380', '001387', '001394',
                        '001401', '001408', '001415', '001422', '001429', '001436', '001443', '001450',
                        '001457', '001464', '001471', '001478', '001485', '001492', '001499', '001506',
                        '001513', '001520', '001527', '001534', '001541', '001548', '001555', '001562',
                        '001569', '001576', '001583', '001590', '001597', '001604', '001611', '001618',
                        '001625', '001632', '001639', '001646', '001653', '001660', '001667', '001674',
                        '001681', '001688', '001695', '001702', '001709', '001716', '001723', '001730',
                        '001737', '001744', '001751', '001758', '001765', '001772', '001779', '001786',
                        '001793', '001800', '001807', '001814', '001821', '001828', '001835', '001842',
                        '001849', '001856', '001863', '001870', '001877', '001884', '001891', '001898',
                        '001905', '001912', '001919', '001926', '001933', '001940', '001947', '001954',
                        '001961', '001968', '001975', '001982', '001989', '001996'
                    ]
                }
            };

            let currentTimelapse = 'kjevik';
            let images = [];
            let loadedCount = 0;
            let totalFrames = 0;
            let currentFrame = 0;
            let animationTimeout = null;
            let isPlaying = true;
            let isUserControlling = false;
            
            // Preload cache for all timelapses
            const preloadedImages = {};
            const preloadStatus = {};

            // Preload all timelapses upfront
            function preloadAllTimelapses() {
                Object.keys(timelapses).forEach(timelapseName => {
                    const timelapse = timelapses[timelapseName];
                    preloadedImages[timelapseName] = [];
                    preloadStatus[timelapseName] = { loaded: 0, total: timelapse.frames.length };
                    
                    timelapse.frames.forEach((frame) => {
                        const img = new Image();
                        img.src = `figs/${timelapse.folder}/frame_${frame}.png`;
                        img.onload = () => {
                            preloadStatus[timelapseName].loaded++;
                        };
                        img.onerror = () => {
                            console.warn(`Failed to preload ${timelapseName} frame_${frame}.png`);
                            preloadStatus[timelapseName].loaded++;
                        };
                        preloadedImages[timelapseName].push(img);
                    });
                });
            }

            function loadTimelapse(timelapseName) {
                // Stop current animation
                if (animationTimeout) {
                    clearTimeout(animationTimeout);
                    animationTimeout = null;
                }
                
                const timelapse = timelapses[timelapseName];
                if (!timelapse) return;
                
                currentTimelapse = timelapseName;
                
                // Use preloaded images if available
                if (preloadedImages[timelapseName] && preloadedImages[timelapseName].length > 0) {
                    images = preloadedImages[timelapseName];
                    totalFrames = timelapse.frames.length;
                    totalFramesCount = totalFrames;
                    currentFrame = 0;
                    isPlaying = true;
                    isUserControlling = false;
                    
                    // Update active option
                    timelapseOptions.forEach(opt => {
                        opt.classList.toggle('active', opt.dataset.timelapse === timelapseName);
                    });
                    
                    // Check if images are already loaded
                    const status = preloadStatus[timelapseName];
                    if (status && status.loaded === status.total) {
                        timelapseImg.classList.add('loaded');
                        timelapseSlider.max = totalFrames - 1;
                        updateFrameInfo();
                        startTimelapse();
                    } else {
                        // Wait for preload to complete
                        timelapseImg.classList.remove('loaded');
                        const checkInterval = setInterval(() => {
                            if (preloadStatus[timelapseName].loaded === preloadStatus[timelapseName].total) {
                                clearInterval(checkInterval);
                                timelapseImg.classList.add('loaded');
                                timelapseSlider.max = totalFrames - 1;
                                updateFrameInfo();
                                startTimelapse();
                            }
                        }, 50);
                    }
                } else {
                    // Fallback: load on demand if preload hasn't started
                    images = [];
                    loadedCount = 0;
                    totalFrames = timelapse.frames.length;
                    totalFramesCount = totalFrames;
                    currentFrame = 0;
                    isPlaying = true;
                    isUserControlling = false;
                    timelapseImg.classList.remove('loaded');
                    
                    // Update active option
                    timelapseOptions.forEach(opt => {
                        opt.classList.toggle('active', opt.dataset.timelapse === timelapseName);
                    });
                    
                    // Preload images
                    timelapse.frames.forEach((frame) => {
                        const img = new Image();
                        img.src = `figs/${timelapse.folder}/frame_${frame}.png`;
                        img.onload = () => {
                            loadedCount++;
                            if (loadedCount === totalFrames) {
                                timelapseImg.classList.add('loaded');
                                timelapseSlider.max = totalFrames - 1;
                                updateFrameInfo();
                                startTimelapse();
                            }
                        };
                        img.onerror = () => {
                            console.warn(`Failed to load frame_${frame}.png`);
                            loadedCount++;
                            if (loadedCount === totalFrames) {
                                timelapseImg.classList.add('loaded');
                                timelapseSlider.max = totalFrames - 1;
                                updateFrameInfo();
                                startTimelapse();
                            }
                        };
                        images.push(img);
                    });
                }
            }

            function updateFrameInfo() {
                if (timelapseFrameInfo) {
                    timelapseFrameInfo.textContent = `Frame ${currentFrame + 1} / ${totalFrames}`;
                }
            }

            function showFrame(frameIndex) {
                if (frameIndex >= 0 && frameIndex < totalFrames) {
                    timelapseImg.src = images[frameIndex].src;
                    currentFrame = frameIndex;
                    timelapseSlider.value = frameIndex;
                    updateFrameInfo();
                }
            }

            const totalDuration = 3000; // 3 seconds total for all timelapses
            let totalFramesCount = 0;
            
            // Calculate variable frame durations: slower at start, faster at end
            // Adjusted to ensure all timelapses take the same total duration
            function getFrameDuration(frameIndex) {
                const progress = frameIndex / totalFramesCount; // 0 to 1
                // Calculate base durations that scale with total frames to maintain consistent total time
                // For fewer frames, each frame gets more time; for more frames, less time
                const avgDuration = totalDuration / totalFramesCount;
                // Start slower (1.5x average), end faster (0.5x average)
                const startDuration = avgDuration * 1.5;
                const endDuration = avgDuration * 0.5;
                const easing = Math.pow(progress, 0.5); // Square root easing for smooth acceleration
                return startDuration - (startDuration - endDuration) * easing;
            }

            function startTimelapse() {
                function showNextFrame() {
                    if (!isPlaying || isUserControlling) return;
                    
                    currentFrame = (currentFrame + 1) % totalFramesCount; // Loop back to 0
                    showFrame(currentFrame);
                    
                    const frameIndex = currentFrame;
                    const duration = getFrameDuration(frameIndex);
                    animationTimeout = setTimeout(showNextFrame, duration);
                }

                // Show first frame immediately
                showFrame(0);
                // Start animation
                const duration = getFrameDuration(0);
                animationTimeout = setTimeout(showNextFrame, duration);
            }

            // Slider control
            timelapseSlider.addEventListener('input', (e) => {
                isUserControlling = true;
                const frameIndex = parseInt(e.target.value);
                showFrame(frameIndex);
            });

            timelapseSlider.addEventListener('mouseup', () => {
                // Resume animation after a short delay
                setTimeout(() => {
                    isUserControlling = false;
                    if (isPlaying) {
                        if (animationTimeout) clearTimeout(animationTimeout);
                        const duration = getFrameDuration(currentFrame);
                        animationTimeout = setTimeout(() => {
                            function continueAnimation() {
                                if (!isPlaying || isUserControlling) return;
                                currentFrame = (currentFrame + 1) % totalFramesCount;
                                showFrame(currentFrame);
                                const duration = getFrameDuration(currentFrame);
                                animationTimeout = setTimeout(continueAnimation, duration);
                            }
                            continueAnimation();
                        }, duration);
                    }
                }, 500);
            });

            // Pause/resume on click
            timelapseImg.addEventListener('click', () => {
                isPlaying = !isPlaying;
                if (isPlaying && !isUserControlling) {
                    if (animationTimeout) clearTimeout(animationTimeout);
                    function continueAnimation() {
                        if (!isPlaying || isUserControlling) return;
                        currentFrame = (currentFrame + 1) % totalFramesCount;
                        showFrame(currentFrame);
                        const duration = getFrameDuration(currentFrame);
                        animationTimeout = setTimeout(continueAnimation, duration);
                    }
                    const duration = getFrameDuration(currentFrame);
                    animationTimeout = setTimeout(continueAnimation, duration);
                } else if (!isPlaying) {
                    if (animationTimeout) clearTimeout(animationTimeout);
                }
            });

            // Timelapse selector
            timelapseOptions.forEach(option => {
                option.addEventListener('click', () => {
                    const timelapseName = option.dataset.timelapse;
                    if (timelapseName !== currentTimelapse) {
                        loadTimelapse(timelapseName);
                    }
                });
            });

            // Preload all timelapses upfront
            preloadAllTimelapses();
            
            // Load initial timelapse
            loadTimelapse('kjevik');
        }

        // Initialize zoomed comparison interaction
        function initZoomedComparison() {
            const mainContext = document.querySelector('.main-context');
            const mainImg = document.getElementById('main-context-img');
            const zoomBox = document.querySelector('.zoom-indicator-box');
            const lrCanvas = document.getElementById('lr-crop-canvas');
            const hrCanvas = document.getElementById('hr-crop-canvas');
            
            if (!mainContext || !mainImg || !zoomBox || !lrCanvas || !hrCanvas) return;
            
            const lrCtx = lrCanvas.getContext('2d');
            const hrCtx = hrCanvas.getContext('2d');
            if (!lrCtx || !hrCtx) return;
            lrCtx.imageSmoothingEnabled = false;
            
            const lrImage = new Image();
            lrImage.src = lrCanvas.dataset.src;
            
            const zoomFactor = 4;
            let boxSize = 0;
            let isPointerDown = false;
            let currentRelX = 0.5;
            let currentRelY = 0.5;
            
            function waitForImage(img) {
                return new Promise((resolve) => {
                    if (img.complete && img.naturalWidth) {
                        resolve();
                    } else {
                        img.addEventListener('load', resolve, { once: true });
                    }
                });
            }
            
            function clamp(value, min, max) {
                return Math.max(min, Math.min(max, value));
            }
            
            function getMetrics() {
                const containerRect = mainContext.getBoundingClientRect();
                const naturalWidth = mainImg.naturalWidth;
                const naturalHeight = mainImg.naturalHeight;
                const scale = Math.max(
                    containerRect.width / naturalWidth,
                    containerRect.height / naturalHeight
                );
                const drawWidth = naturalWidth * scale;
                const drawHeight = naturalHeight * scale;
                const offsetX = (containerRect.width - drawWidth) / 2;
                const offsetY = (containerRect.height - drawHeight) / 2;
                return { containerRect, naturalWidth, naturalHeight, scale, drawWidth, drawHeight, offsetX, offsetY };
            }
            
            function setBoxSize() {
                const { containerRect } = getMetrics();
                boxSize = containerRect.width / zoomFactor;
                zoomBox.style.width = `${boxSize}px`;
                zoomBox.style.height = `${boxSize}px`;
            }
            
            function placeBoxAtRel(relX, relY) {
                const metrics = getMetrics();
                const { offsetX, offsetY, drawWidth, drawHeight } = metrics;
                const centerX = offsetX + relX * drawWidth;
                const centerY = offsetY + relY * drawHeight;
                moveBox(centerX, centerY, metrics);
            }
            
            function moveBox(centerX, centerY, metrics = getMetrics()) {
                const { containerRect } = metrics;
                const half = boxSize / 2;
                const clampedX = clamp(centerX, half, containerRect.width - half);
                const clampedY = clamp(centerY, half, containerRect.height - half);
                zoomBox.style.left = `${clampedX - half}px`;
                zoomBox.style.top = `${clampedY - half}px`;
                drawCrops(clampedX, clampedY, metrics);
            }
            
            function drawCrops(centerX, centerY, metrics = getMetrics()) {
                const { naturalWidth, naturalHeight, scale, offsetX, offsetY, drawWidth, drawHeight } = metrics;
                const relX = (centerX - offsetX) / drawWidth;
                const relY = (centerY - offsetY) / drawHeight;
                const clampedRelX = clamp(relX, 0, 1);
                const clampedRelY = clamp(relY, 0, 1);
                
                const cropSize = boxSize / scale;
                const halfCrop = cropSize / 2;
                const imgCenterX = clamp(clampedRelX * naturalWidth, halfCrop, naturalWidth - halfCrop);
                const imgCenterY = clamp(clampedRelY * naturalHeight, halfCrop, naturalHeight - halfCrop);
                
                currentRelX = imgCenterX / naturalWidth;
                currentRelY = imgCenterY / naturalHeight;
                
                const sx = imgCenterX - halfCrop;
                const sy = imgCenterY - halfCrop;
                
                hrCtx.clearRect(0, 0, hrCanvas.width, hrCanvas.height);
                hrCtx.drawImage(
                    mainImg,
                    sx,
                    sy,
                    cropSize,
                    cropSize,
                    0,
                    0,
                    hrCanvas.width,
                    hrCanvas.height
                );
                
                const lrScaleX = lrImage.naturalWidth / naturalWidth;
                const lrScaleY = lrImage.naturalHeight / naturalHeight;
                const lrCropWidth = cropSize * lrScaleX;
                const lrCropHeight = cropSize * lrScaleY;
                const lrSx = sx * lrScaleX;
                const lrSy = sy * lrScaleY;
                
                lrCtx.clearRect(0, 0, lrCanvas.width, lrCanvas.height);
                lrCtx.drawImage(
                    lrImage,
                    lrSx,
                    lrSy,
                    lrCropWidth,
                    lrCropHeight,
                    0,
                    0,
                    lrCanvas.width,
                    lrCanvas.height
                );
            }
            
            function handlePointerEvent(e) {
                const metrics = getMetrics();
                const { containerRect } = metrics;
                const x = e.clientX - containerRect.left;
                const y = e.clientY - containerRect.top;
                moveBox(x, y, metrics);
            }
            
            function handleResize() {
                setBoxSize();
                placeBoxAtRel(currentRelX, currentRelY);
            }
            
            function attachPointerEvents() {
                mainContext.addEventListener('pointerdown', (e) => {
                    isPointerDown = true;
                    mainContext.classList.add('dragging');
                    mainContext.setPointerCapture(e.pointerId);
                    handlePointerEvent(e);
                });
                
                mainContext.addEventListener('pointermove', (e) => {
                    if (!isPointerDown) return;
                    handlePointerEvent(e);
                });
                
                mainContext.addEventListener('pointerup', (e) => {
                    isPointerDown = false;
                    mainContext.classList.remove('dragging');
                    mainContext.releasePointerCapture(e.pointerId);
                });
                
                mainContext.addEventListener('pointerleave', () => {
                    isPointerDown = false;
                    mainContext.classList.remove('dragging');
                });
            }
            
            Promise.all([waitForImage(mainImg), waitForImage(lrImage)]).then(() => {
                setBoxSize();
                placeBoxAtRel(currentRelX, currentRelY);
                attachPointerEvents();
                window.addEventListener('resize', handleResize);
            });
        }

        // Before/after comparison sliders
        function initComparisonSliders() {
            const cards = document.querySelectorAll('.comparison-card');
            if (!cards.length) return;

            cards.forEach((card) => {
                const stage = card.querySelector('.comparison-stage');
                const overlay = card.querySelector('.comparison-overlay');
                const handle = card.querySelector('.comparison-handle');

                if (!stage || !overlay || !handle) return;

                let isPointerDown = false;

                const setPercent = (value) => {
                    const clamped = Math.min(100, Math.max(0, value));
                    card.style.setProperty('--percent', clamped);
                };

                const pointerMove = (clientX) => {
                    const rect = stage.getBoundingClientRect();
                    const percent = ((clientX - rect.left) / rect.width) * 100;
                    setPercent(percent);
                };

                stage.addEventListener('pointerdown', (e) => {
                    isPointerDown = true;
                    stage.setPointerCapture(e.pointerId);
                    pointerMove(e.clientX);
                });

                stage.addEventListener('pointermove', (e) => {
                    if (!isPointerDown) return;
                    pointerMove(e.clientX);
                });

                stage.addEventListener('pointerup', (e) => {
                    isPointerDown = false;
                    stage.releasePointerCapture(e.pointerId);
                });

                stage.addEventListener('pointerleave', () => {
                    isPointerDown = false;
                });
            });
        }

        // Initialize timelapse
        document.addEventListener('DOMContentLoaded', () => {
            initTimelapse();                        // For Timelapse
            initZoomedComparison();                 // For Zoomed Comparison
            initComparisonSliders();                // For Input vs Output sliders
        });
    </script>
</body>
</html>